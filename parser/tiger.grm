structure A = Absyn
(* user declarations *)
(* You can define values available in the semantic actions of the rules in the user declarations section. It is recommended that you keep the size of this section as small as possible and place large blocks of code in other modules. *)
%%
(* ML-Yacc declarations *)
(* You must declare the nonterminals and terminals and the types of the values associated with them there. You must also name the parser and declare the type of position values. You should specify the set of terminals which can follow the start symbol and the set of non-shiftable terminals. You may optionally declare precedences for terminals, make declarations that will improve error-recovery, and suppress the generation of default reductions in the parser. You may declare whether the parser generator should create a verbose description of the parser in a ``.desc'' file. This is useful for finding the causes of shift/reduce errors and other parsing conflicts. *)

(* You may also declare whether the semantic actions are free of significant side-effects and always terminate. Normally, ML-Yacc delays the evaluation of semantic actions until the completion of a successful parse. This ensures that there will be no semantic actions to ``undo'' if a syntactic error-correction invalidates some semantic actions. If, however, the semantic actions are free of significant side-effects and always terminate, the results of semantic actions that are invalidated by a syntactic error-correction can always be safely ignored. *)

(* Parsers run faster and need less memory when it is not necessary to delay the evaluation of semantic actions. You are encouraged to write semantic actions that are free of side-effects and always terminate and to declare this information to ML-Yacc. *)

(* A semantic action is free of significant side-effects if it can be reexecuted a reasonably small number of times without affecting the result of a parse. (The reexecution occurs when the error-correcting parser is testing possible corrections to fix a syntax error, and the number of times reexecution occurs is roughly bounded, for each syntax error, by the number of terminals times the amount of lookahead permitted for the error-correcting parser). *)

(* our terminal symbols *)
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

(* our non-terminal symbols - add any new ones here *)
%nonterm  exp | program of A.exp

%pos int
%verbose
%start program
(* You should specify the set of terminals that may follow the start symbol, also called end-of-parse symbols, using the %eop declaration. *)
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%
(* Rules *)
(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)

(* The rules section contains the context-free grammar productions and their associated semantic actions. *)

(* A rule consists of a left hand side nonterminal, followed by a colon, followed by a list of right hand side clauses.

The right hand side clauses should be separated by bars (``|''). Each clause consists of a list of nonterminal and terminal symbols, followed by an optional %prec declaration, and then followed by the code to be evaluated when the rule is reduced.

The optional %prec consists of the keyword %prec followed by a terminal whose precedence should be used as the precedence of the rule.

The values of those symbols on the right hand side which have values are available inside the code. Positions for all the symbols are also available. Each value has the general form {symbol name}{n+1}, where {n} is the number of occurrences of the symbol to the left of the symbol. If the symbol occurs only once in the rule, {symbol name} may also be used. The positions are given by {symbol name}{n+1}left and {symbol name}{n+1}right. where {n} is defined as before. The position for a null rhs of a production is assumed to be the leftmost position of the lookahead terminal which is causing the reduction. This position value is available in defaultPos.

The value to which the code evaluates is used as the value of the nonterminal. The type of the value and the nonterminal must match. The value is ignored if the nonterminal has no value, but is still evaluated for side-effects. *)


program	: expr	()

	
expr: 
   STRING	()
  | INT ()
  | NIL ()
  | lvalue ()
  | expr BINOP expr
  | lvalue ASSIGN expr ()
  | ID LPAREN exprList RPAREN ()
  | ID ()
  | LPAREN exprSeq RPAREN ()
  | typeID LBRACE fieldList RBRACE ()
  | typeID ()
  | typeID LBRACK expr RBRACK OF expr ()
  | IF expr THEN expr ()
  | IF expr THEN expr ELSE expr ()
  | WHILE expr DO expr ()
  | FOR ID ASSIGN expr TO expr DO expr ()
  | BREAK ()
  | LET declarationList in expSeq END ()

exprSeq: 
  exp ()
  | exprSeq SEMICOLON expr ()

exprList:
  expr ()
  | exprList COMMA expr ()

fieldList:
  ID EQ expr
  | fieldList COMMA ID EQ expr ()


lvalue: 
  ID ()
  | lvalue DOT ID ()
  | lvalue LBRACK expr RBRACK ()

declarationList: 
  declaration ()
  | declarationList declaration ()

declaration:
  typeDeclaration ()
  | variableDeclaration ()
  | functionDeclaration ()

typeDeclaration:
  TYPE typeID EQ type ()

type:
  typeID ()
| LBRACE typeFields RBRACE ()
| ARRAY OF typeID ()

typeFields:
  typeField ()
| typeFields COMMA typeField ()

typeField:()
ID COLON typeID ()

variableDeclaration:
  VAR ID ASSIGN expr ()
  | VAR ID COLON typeID ASSIGN expr ()

functionDeclaration:
  FUNCTION ID RPAREN typeFields LPAREN EQ expr ()
  | FUNCTION ID EQ expr ()
  | FUNCTION ID RPAREN typeFields LPAREN COLON typeID EQ expr ()
  | FUNCTION ID COLON typeID EQ expr ()

typeID:
  ID ()


